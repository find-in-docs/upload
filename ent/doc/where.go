// Code generated by entc, DO NOT EDIT.

package doc

import (
	"entgo.io/ent/dialect/sql"
	"github.com/samirgadkari/search/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id uint32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uint32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uint32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uint32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uint32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uint32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uint32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uint32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uint32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// WordInts applies equality check predicate on the "wordInts" field. It's identical to WordIntsEQ.
func WordInts(v []byte) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWordInts), v))
	})
}

// InputDocId applies equality check predicate on the "inputDocId" field. It's identical to InputDocIdEQ.
func InputDocId(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldInputDocId), v))
	})
}

// UserId applies equality check predicate on the "userId" field. It's identical to UserIdEQ.
func UserId(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserId), v))
	})
}

// BusinessId applies equality check predicate on the "businessId" field. It's identical to BusinessIdEQ.
func BusinessId(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBusinessId), v))
	})
}

// Stars applies equality check predicate on the "stars" field. It's identical to StarsEQ.
func Stars(v float32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStars), v))
	})
}

// Useful applies equality check predicate on the "useful" field. It's identical to UsefulEQ.
func Useful(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUseful), v))
	})
}

// Funny applies equality check predicate on the "funny" field. It's identical to FunnyEQ.
func Funny(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFunny), v))
	})
}

// Cool applies equality check predicate on the "cool" field. It's identical to CoolEQ.
func Cool(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCool), v))
	})
}

// Text applies equality check predicate on the "text" field. It's identical to TextEQ.
func Text(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldText), v))
	})
}

// Date applies equality check predicate on the "date" field. It's identical to DateEQ.
func Date(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDate), v))
	})
}

// WordIntsEQ applies the EQ predicate on the "wordInts" field.
func WordIntsEQ(v []byte) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWordInts), v))
	})
}

// WordIntsNEQ applies the NEQ predicate on the "wordInts" field.
func WordIntsNEQ(v []byte) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWordInts), v))
	})
}

// WordIntsIn applies the In predicate on the "wordInts" field.
func WordIntsIn(vs ...[]byte) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWordInts), v...))
	})
}

// WordIntsNotIn applies the NotIn predicate on the "wordInts" field.
func WordIntsNotIn(vs ...[]byte) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWordInts), v...))
	})
}

// WordIntsGT applies the GT predicate on the "wordInts" field.
func WordIntsGT(v []byte) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWordInts), v))
	})
}

// WordIntsGTE applies the GTE predicate on the "wordInts" field.
func WordIntsGTE(v []byte) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWordInts), v))
	})
}

// WordIntsLT applies the LT predicate on the "wordInts" field.
func WordIntsLT(v []byte) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWordInts), v))
	})
}

// WordIntsLTE applies the LTE predicate on the "wordInts" field.
func WordIntsLTE(v []byte) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWordInts), v))
	})
}

// InputDocIdEQ applies the EQ predicate on the "inputDocId" field.
func InputDocIdEQ(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldInputDocId), v))
	})
}

// InputDocIdNEQ applies the NEQ predicate on the "inputDocId" field.
func InputDocIdNEQ(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldInputDocId), v))
	})
}

// InputDocIdIn applies the In predicate on the "inputDocId" field.
func InputDocIdIn(vs ...string) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldInputDocId), v...))
	})
}

// InputDocIdNotIn applies the NotIn predicate on the "inputDocId" field.
func InputDocIdNotIn(vs ...string) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldInputDocId), v...))
	})
}

// InputDocIdGT applies the GT predicate on the "inputDocId" field.
func InputDocIdGT(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldInputDocId), v))
	})
}

// InputDocIdGTE applies the GTE predicate on the "inputDocId" field.
func InputDocIdGTE(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldInputDocId), v))
	})
}

// InputDocIdLT applies the LT predicate on the "inputDocId" field.
func InputDocIdLT(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldInputDocId), v))
	})
}

// InputDocIdLTE applies the LTE predicate on the "inputDocId" field.
func InputDocIdLTE(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldInputDocId), v))
	})
}

// InputDocIdContains applies the Contains predicate on the "inputDocId" field.
func InputDocIdContains(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldInputDocId), v))
	})
}

// InputDocIdHasPrefix applies the HasPrefix predicate on the "inputDocId" field.
func InputDocIdHasPrefix(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldInputDocId), v))
	})
}

// InputDocIdHasSuffix applies the HasSuffix predicate on the "inputDocId" field.
func InputDocIdHasSuffix(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldInputDocId), v))
	})
}

// InputDocIdEqualFold applies the EqualFold predicate on the "inputDocId" field.
func InputDocIdEqualFold(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldInputDocId), v))
	})
}

// InputDocIdContainsFold applies the ContainsFold predicate on the "inputDocId" field.
func InputDocIdContainsFold(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldInputDocId), v))
	})
}

// UserIdEQ applies the EQ predicate on the "userId" field.
func UserIdEQ(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserId), v))
	})
}

// UserIdNEQ applies the NEQ predicate on the "userId" field.
func UserIdNEQ(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserId), v))
	})
}

// UserIdIn applies the In predicate on the "userId" field.
func UserIdIn(vs ...string) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserId), v...))
	})
}

// UserIdNotIn applies the NotIn predicate on the "userId" field.
func UserIdNotIn(vs ...string) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserId), v...))
	})
}

// UserIdGT applies the GT predicate on the "userId" field.
func UserIdGT(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserId), v))
	})
}

// UserIdGTE applies the GTE predicate on the "userId" field.
func UserIdGTE(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserId), v))
	})
}

// UserIdLT applies the LT predicate on the "userId" field.
func UserIdLT(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserId), v))
	})
}

// UserIdLTE applies the LTE predicate on the "userId" field.
func UserIdLTE(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserId), v))
	})
}

// UserIdContains applies the Contains predicate on the "userId" field.
func UserIdContains(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUserId), v))
	})
}

// UserIdHasPrefix applies the HasPrefix predicate on the "userId" field.
func UserIdHasPrefix(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUserId), v))
	})
}

// UserIdHasSuffix applies the HasSuffix predicate on the "userId" field.
func UserIdHasSuffix(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUserId), v))
	})
}

// UserIdEqualFold applies the EqualFold predicate on the "userId" field.
func UserIdEqualFold(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUserId), v))
	})
}

// UserIdContainsFold applies the ContainsFold predicate on the "userId" field.
func UserIdContainsFold(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUserId), v))
	})
}

// BusinessIdEQ applies the EQ predicate on the "businessId" field.
func BusinessIdEQ(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBusinessId), v))
	})
}

// BusinessIdNEQ applies the NEQ predicate on the "businessId" field.
func BusinessIdNEQ(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBusinessId), v))
	})
}

// BusinessIdIn applies the In predicate on the "businessId" field.
func BusinessIdIn(vs ...string) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBusinessId), v...))
	})
}

// BusinessIdNotIn applies the NotIn predicate on the "businessId" field.
func BusinessIdNotIn(vs ...string) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBusinessId), v...))
	})
}

// BusinessIdGT applies the GT predicate on the "businessId" field.
func BusinessIdGT(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBusinessId), v))
	})
}

// BusinessIdGTE applies the GTE predicate on the "businessId" field.
func BusinessIdGTE(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBusinessId), v))
	})
}

// BusinessIdLT applies the LT predicate on the "businessId" field.
func BusinessIdLT(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBusinessId), v))
	})
}

// BusinessIdLTE applies the LTE predicate on the "businessId" field.
func BusinessIdLTE(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBusinessId), v))
	})
}

// BusinessIdContains applies the Contains predicate on the "businessId" field.
func BusinessIdContains(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldBusinessId), v))
	})
}

// BusinessIdHasPrefix applies the HasPrefix predicate on the "businessId" field.
func BusinessIdHasPrefix(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldBusinessId), v))
	})
}

// BusinessIdHasSuffix applies the HasSuffix predicate on the "businessId" field.
func BusinessIdHasSuffix(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldBusinessId), v))
	})
}

// BusinessIdEqualFold applies the EqualFold predicate on the "businessId" field.
func BusinessIdEqualFold(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldBusinessId), v))
	})
}

// BusinessIdContainsFold applies the ContainsFold predicate on the "businessId" field.
func BusinessIdContainsFold(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldBusinessId), v))
	})
}

// StarsEQ applies the EQ predicate on the "stars" field.
func StarsEQ(v float32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStars), v))
	})
}

// StarsNEQ applies the NEQ predicate on the "stars" field.
func StarsNEQ(v float32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStars), v))
	})
}

// StarsIn applies the In predicate on the "stars" field.
func StarsIn(vs ...float32) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStars), v...))
	})
}

// StarsNotIn applies the NotIn predicate on the "stars" field.
func StarsNotIn(vs ...float32) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStars), v...))
	})
}

// StarsGT applies the GT predicate on the "stars" field.
func StarsGT(v float32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStars), v))
	})
}

// StarsGTE applies the GTE predicate on the "stars" field.
func StarsGTE(v float32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStars), v))
	})
}

// StarsLT applies the LT predicate on the "stars" field.
func StarsLT(v float32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStars), v))
	})
}

// StarsLTE applies the LTE predicate on the "stars" field.
func StarsLTE(v float32) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStars), v))
	})
}

// UsefulEQ applies the EQ predicate on the "useful" field.
func UsefulEQ(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUseful), v))
	})
}

// UsefulNEQ applies the NEQ predicate on the "useful" field.
func UsefulNEQ(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUseful), v))
	})
}

// UsefulIn applies the In predicate on the "useful" field.
func UsefulIn(vs ...int16) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUseful), v...))
	})
}

// UsefulNotIn applies the NotIn predicate on the "useful" field.
func UsefulNotIn(vs ...int16) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUseful), v...))
	})
}

// UsefulGT applies the GT predicate on the "useful" field.
func UsefulGT(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUseful), v))
	})
}

// UsefulGTE applies the GTE predicate on the "useful" field.
func UsefulGTE(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUseful), v))
	})
}

// UsefulLT applies the LT predicate on the "useful" field.
func UsefulLT(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUseful), v))
	})
}

// UsefulLTE applies the LTE predicate on the "useful" field.
func UsefulLTE(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUseful), v))
	})
}

// FunnyEQ applies the EQ predicate on the "funny" field.
func FunnyEQ(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFunny), v))
	})
}

// FunnyNEQ applies the NEQ predicate on the "funny" field.
func FunnyNEQ(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFunny), v))
	})
}

// FunnyIn applies the In predicate on the "funny" field.
func FunnyIn(vs ...int16) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFunny), v...))
	})
}

// FunnyNotIn applies the NotIn predicate on the "funny" field.
func FunnyNotIn(vs ...int16) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFunny), v...))
	})
}

// FunnyGT applies the GT predicate on the "funny" field.
func FunnyGT(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFunny), v))
	})
}

// FunnyGTE applies the GTE predicate on the "funny" field.
func FunnyGTE(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFunny), v))
	})
}

// FunnyLT applies the LT predicate on the "funny" field.
func FunnyLT(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFunny), v))
	})
}

// FunnyLTE applies the LTE predicate on the "funny" field.
func FunnyLTE(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFunny), v))
	})
}

// CoolEQ applies the EQ predicate on the "cool" field.
func CoolEQ(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCool), v))
	})
}

// CoolNEQ applies the NEQ predicate on the "cool" field.
func CoolNEQ(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCool), v))
	})
}

// CoolIn applies the In predicate on the "cool" field.
func CoolIn(vs ...int16) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCool), v...))
	})
}

// CoolNotIn applies the NotIn predicate on the "cool" field.
func CoolNotIn(vs ...int16) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCool), v...))
	})
}

// CoolGT applies the GT predicate on the "cool" field.
func CoolGT(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCool), v))
	})
}

// CoolGTE applies the GTE predicate on the "cool" field.
func CoolGTE(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCool), v))
	})
}

// CoolLT applies the LT predicate on the "cool" field.
func CoolLT(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCool), v))
	})
}

// CoolLTE applies the LTE predicate on the "cool" field.
func CoolLTE(v int16) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCool), v))
	})
}

// TextEQ applies the EQ predicate on the "text" field.
func TextEQ(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldText), v))
	})
}

// TextNEQ applies the NEQ predicate on the "text" field.
func TextNEQ(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldText), v))
	})
}

// TextIn applies the In predicate on the "text" field.
func TextIn(vs ...string) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldText), v...))
	})
}

// TextNotIn applies the NotIn predicate on the "text" field.
func TextNotIn(vs ...string) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldText), v...))
	})
}

// TextGT applies the GT predicate on the "text" field.
func TextGT(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldText), v))
	})
}

// TextGTE applies the GTE predicate on the "text" field.
func TextGTE(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldText), v))
	})
}

// TextLT applies the LT predicate on the "text" field.
func TextLT(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldText), v))
	})
}

// TextLTE applies the LTE predicate on the "text" field.
func TextLTE(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldText), v))
	})
}

// TextContains applies the Contains predicate on the "text" field.
func TextContains(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldText), v))
	})
}

// TextHasPrefix applies the HasPrefix predicate on the "text" field.
func TextHasPrefix(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldText), v))
	})
}

// TextHasSuffix applies the HasSuffix predicate on the "text" field.
func TextHasSuffix(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldText), v))
	})
}

// TextEqualFold applies the EqualFold predicate on the "text" field.
func TextEqualFold(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldText), v))
	})
}

// TextContainsFold applies the ContainsFold predicate on the "text" field.
func TextContainsFold(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldText), v))
	})
}

// DateEQ applies the EQ predicate on the "date" field.
func DateEQ(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDate), v))
	})
}

// DateNEQ applies the NEQ predicate on the "date" field.
func DateNEQ(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDate), v))
	})
}

// DateIn applies the In predicate on the "date" field.
func DateIn(vs ...string) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDate), v...))
	})
}

// DateNotIn applies the NotIn predicate on the "date" field.
func DateNotIn(vs ...string) predicate.Doc {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Doc(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDate), v...))
	})
}

// DateGT applies the GT predicate on the "date" field.
func DateGT(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDate), v))
	})
}

// DateGTE applies the GTE predicate on the "date" field.
func DateGTE(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDate), v))
	})
}

// DateLT applies the LT predicate on the "date" field.
func DateLT(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDate), v))
	})
}

// DateLTE applies the LTE predicate on the "date" field.
func DateLTE(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDate), v))
	})
}

// DateContains applies the Contains predicate on the "date" field.
func DateContains(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldDate), v))
	})
}

// DateHasPrefix applies the HasPrefix predicate on the "date" field.
func DateHasPrefix(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldDate), v))
	})
}

// DateHasSuffix applies the HasSuffix predicate on the "date" field.
func DateHasSuffix(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldDate), v))
	})
}

// DateEqualFold applies the EqualFold predicate on the "date" field.
func DateEqualFold(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldDate), v))
	})
}

// DateContainsFold applies the ContainsFold predicate on the "date" field.
func DateContainsFold(v string) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldDate), v))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Doc) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Doc) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Doc) predicate.Doc {
	return predicate.Doc(func(s *sql.Selector) {
		p(s.Not())
	})
}
